/*!
 * Circle Progress - v1.0.0 - 2025-10-26
 * https://tigrr.github.io/circle-progress/
 * Copyright (c) Tigran Sargsyan
 * Licensed MIT
 */

class t extends HTMLElement {
    static styles = "";
    static props = {};
    #t = {};
    #e = {};
    #a = new Set;

    constructor() {
        super();
        const t = this.attachShadow({ mode: "open" }),
            { styles: e } = this.constructor;

        if (e) {
            const a = document.createElement("style");
            a.textContent = e;
            t.append(a);
        }

        const { props: a } = this.constructor;
        if (a)
            for (const [t, e] of Object.entries(a)) {
                if (e.attribute) {
                    this.#t[t] = e.attribute;
                    this.#e[e.attribute] = t;
                }
                if (e.type === Boolean) this.#a.add(t);
            }
    }

    attributeUpdated(t, e) { }

    _attrNameToProp(t) {
        return this.#e[t] ?? t;
    }

    _propToAttrName(t) {
        return this.#t[t] ?? t;
    }

    _attrValToProp(t, e) {
        return this.#a.has(t) ? e !== null : e;
    }

    #i = false;

    attributeChangedCallback(t, e, a) {
        if (this.#i) {
            this.#i = false;
        } else {
            this.attributeUpdated?.(
                this._attrNameToProp(t),
                this._attrValToProp(t, a)
            );
        }
    }

    reflectPropToAttribute(t) {
        const e = this[t];
        this.#i = true;
        const a = this._propToAttrName(t);

        if (this.#a.has(t)) {
            e ? this.setAttribute(a, "") : this.removeAttribute(a);
        } else {
            typeof e === "function"
                ? this.removeAttribute(a)
                : this.setAttribute(a, String(e));
        }
    }
}

const e = function (t, e, i, r) {
    r = r || document;
    const n = Object.create(a);

    if (typeof t === "string") t = r.querySelector(t);
    if (!t) return;

    const s = r.createElementNS("http://www.w3.org/2000/svg", "svg");
    s.setAttribute("version", "1.1");
    s.setAttribute("width", String(e));
    s.setAttribute("height", String(i));
    s.setAttribute("viewBox", "0 0 " + e + " " + i);
    t.appendChild(s);

    n.svg = s;
    return n;
};

const a = {
    element: function (t, e, a, r) {
        const n = i(this, t, e, r);
        if (a) n.el.innerHTML = a;
        return n;
    }
};

const i = function (t, e, a, i, n) {
    n = n || document;
    const s = Object.create(r);
    s.el = n.createElementNS("http://www.w3.org/2000/svg", e);
    s.attr(a);
    (i ? ("el" in i ? i.el : i) : t.svg).appendChild(s.el);
    return s;
};

const r = {
    attr: function (t, e) {
        if (t === undefined) return this;

        if (typeof t === "object") {
            for (let e in t) this.attr(e, t[e]);
            return this;
        }

        if (e === undefined) return this.el.getAttributeNS(null, t);

        this.el.setAttribute(t, e);
        return this;
    },
    content: function (t) {
        this.el.innerHTML = t;
        return this;
    }
};

const n = {
    linear: (t, e, a, i) => a * t / i + e,
    easeInQuad: (t, e, a, i) => a * (t /= i) * t + e,
    easeOutQuad: (t, e, a, i) => -a * (t /= i) * (t - 2) + e,
    easeInOutQuad: (t, e, a, i) =>
        (t /= i / 2) < 1 ? (a / 2) * t * t + e : (-a / 2) * (--t * (t - 2) - 1) + e,
    easeInCubic: (t, e, a, i) => a * (t /= i) * t * t + e,
    easeOutCubic: (t, e, a, i) => a * ((t = t / i - 1) * t * t + 1) + e,
    easeInOutCubic: (t, e, a, i) =>
        (t /= i / 2) < 1
            ? (a / 2) * t * t * t + e
            : (a / 2) * ((t -= 2) * t * t + 2) + e,
    easeInQuart: (t, e, a, i) => a * (t /= i) * t * t * t + e,
    easeOutQuart: (t, e, a, i) => -a * ((t = t / i - 1) * t * t * t - 1) + e,
    easeInOutQuart: (t, e, a, i) =>
        (t /= i / 2) < 1
            ? (a / 2) * t * t * t * t + e
            : (-a / 2) * ((t -= 2) * t * t * 2) + e,
    easeInQuint: (t, e, a, i) => a * (t /= i) * t * t * t * t + e,
    easeOutQuint: (t, e, a, i) => a * ((t = t / i - 1) * t * t * t * t + 1) + e,
    easeInOutQuint: (t, e, a, i) =>
        (t /= i / 2) < 1
            ? (a / 2) * t * t * t * t * t + e
            : (a / 2) * ((t -= 2) * t * t * t * t + 2) + e,
    easeInSine: (t, e, a, i) => -a * Math.cos((t / i) * (Math.PI / 2)) + a + e,
    easeOutSine: (t, e, a, i) => a * Math.sin((t / i) * (Math.PI / 2)) + e,
    easeInOutSine: (t, e, a, i) =>
        (-a / 2) * (Math.cos(Math.PI * t / i) - 1) + e,
    easeInExpo: (t, e, a, i) => a * Math.pow(2, 10 * (t / i - 1)) + e,
    easeOutExpo: (t, e, a, i) => a * (1 - Math.pow(2, -10 * t / i)) + e,
    easeInOutExpo: (t, e, a, i) =>
        (t /= i / 2) < 1
            ? (a / 2) * Math.pow(2, 10 * (t - 1)) + e
            : (a / 2) * (2 - Math.pow(2, -10 * --t)) + e,
    easeInCirc: (t, e, a, i) => -a * (Math.sqrt(1 - (t /= i) * t) - 1) + e,
    easeOutCirc: (t, e, a, i) =>
        a * Math.sqrt(1 - (t = t / i - 1) * t) + e,
    easeInOutCirc: (t, e, a, i) =>
        (t /= i / 2) < 1
            ? (-a / 2) * (Math.sqrt(1 - t * t) - 1) + e
            : (a / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1) + e
};

const s = (t, e) => ({
    x: t * Math.cos((e * Math.PI) / 180),
    y: t * Math.sin((e * Math.PI) / 180)
});

const o = (t, e, a, i, r, n = false) => {
    r > 0 && r < 0.3 ? (r = 0) : r > 359.999 && (r = 359.999);

    const o = i + r * (2 * +n - 1),
        h = s(a, i),
        u = s(a, o),
        l = t + h.x,
        c = t + u.x;

    return ["M", l, e + h.y, "A", a, a, 0, +(r > 180), +n, c, e + u.y].join(" ");
};

const h = {
    value: "aria-valuenow",
    min: "aria-valuemin",
    max: "aria-valuemax"
};

class u extends t {
    static styles = `
    :host(:not([hidden])) {
        display: inline-block;
    }

    .circle {
        fill: none;
        stroke: #ddd;
    }

    .value {
        fill: none;
        stroke: #00E699;
    }

    .text {
        font: 16px Arial, sans-serif;
        text-anchor: middle;
        fill: #999;
    }

    :host([text-format="valueOnCircle"]) .text-value {
        font-size: 12px;
        fill: #fff;
    }

    :host([text-format="valueOnCircle"]) .text-max {
        font-size: 22px;
        font-weight: bold;
        fill: #ddd;
    }

    :host([text-format="vertical"]) .text-separator {
        font-family: Arial, sans-serif !important;
    }
`;

    value;
    min;
    max;
    startAngle;
    anticlockwise;
    unconstrained;
    indeterminateText;
    textFormat;
    animation;
    animationDuration;

    static props = {
        value: true,
        min: true,
        max: true,
        startAngle: { attribute: "start-angle" },
        anticlockwise: { type: Boolean },
        unconstrained: { type: Boolean },
        indeterminateText: { attribute: "indeterminate-text" },
        textFormat: { attribute: "text-format" },
        animation: true,
        animationDuration: { attribute: "animation-duration" }
    };

    static get observedAttributes() {
        return Object.entries(this.props).map(
            ([t, e]) => (e && typeof e === "object" && e.attribute) || t
        );
    }

    static defaults = {
        startAngle: 0,
        min: 0,
        max: 1,
        unconstrained: false,
        indeterminateText: "?",
        anticlockwise: false,
        textFormat: "horizontal",
        animation: "easeInOutCubic",
        animationDuration: 600
    };

    constructor(t = {}) {
        let stroke;

        super();

        Object.defineProperties(
            this,
            Object.keys(u.props).reduce((acc, key) => {
                acc[key] = {
                    get() {
                        return this._get(key);
                    },
                    set(v) {
                        this.attr(key, v);
                    }
                };
                return acc;
            }, {})
        );

        t = { ...u.defaults, ...t };
        stroke = t.textFormat === "valueOnCircle" ? 16 : 8;

        this.graph = {
            paper: e(this.shadowRoot, 100, 100),
            value: 0
        };

        this.graph.paper.svg.setAttribute("class", "base");
        this.graph.paper.svg.setAttribute("part", "base");
        this.graph.paper.svg.setAttribute("role", "progressbar");

        this.graph.circle = this.graph.paper
            .element("circle")
            .attr({
                class: "circle",
                part: "circle",
                cx: 50,
                cy: 50,
                r: 50 - stroke / 2,
                "stroke-width": stroke
            });

        this.graph.sector = this.graph.paper
            .element("path")
            .attr({
                d: o(50, 50, 50 - stroke / 2, 0, 0),
                class: "value",
                part: "value",
                "stroke-width": stroke
            });

        this.graph.text = this.graph.paper.element(
            "text",
            { class: "text", part: "text", x: 50, y: 50 }
        );

        this._initText();

        Object.keys(u.props).forEach(key => {
            if (key in t) this._set(key, t[key]);
        });
    }

    attributeUpdated(t, e) {
        this._set(t, e);
    }

    #r = {};

    attr(t) {
        if (!["string", "object"].includes(typeof t))
            throw new TypeError(
                `Wrong argument passed to attr. Expected object, got "${typeof t}"`
            );

        if (typeof t === "string") {
            if (arguments.length === 1) return this._get(t);
            t = [[t, arguments[1]]];
        }

        if (!Array.isArray(t)) {
            t = Object.keys(t).map(key => [key, t[key]]);
        }

        t.forEach(([key, value]) => this._set(key, value));
        return this;
    }

    _get(t) {
        this._flushBatch();
        return this.#r[t];
    }

    _set(t, e) {
        e = this._formatValue(t, e);
        if (e === undefined)
            throw new TypeError(
                `Failed to set the ${t} property on CircleProgress: The provided value is non-finite.`
            );

        this._scheduleUpdate(t, e);
    }

    #n = null;
    updateComplete = null;

    _scheduleUpdate(t, e) {
        if (!this.#n) {
            this.#n = {};
            this.updateComplete = Promise.resolve().then(() =>
                this._flushBatch()
            );
        }
        this.#n[t] = e;
    }

    _flushBatch() {
        if (!this.#n) return;

        const t = this.#n;
        this.#n = null;

        let min = t.min ?? this.#r.min;
        let max = t.max ?? this.#r.max;

        if ("min" in t && t.min >= max) min = t.min = max;
        if ("max" in t && t.max <= min) max = t.max = min;

        if ("value" in t && !(t.unconstrained ?? this.#r.unconstrained)) {
            if (min != null && t.value < min) t.value = min;
            if (max != null && t.value > max) t.value = max;
        }

        for (const [key, value] of Object.entries(t)) {
            if (this.#r[key] === value) continue;

            this.#r[key] = value;

            if (key in h) {
                if (value !== undefined)
                    this.graph.paper.svg.setAttribute(h[key], value);
                else
                    this.graph.paper.svg.removeAttribute(h[key]);
            }

            if (["min", "max", "unconstrained"].includes(key)) {
                if (this.value > this.max || this.value < this.min) {
                    this.value = Math.min(
                        this.max,
                        Math.max(this.min, this.value)
                    );
                }
            }

            if (key === "textFormat") {
                this._initText();
                const strokeWidth =
                    value === "valueOnCircle" ? 16 : 8;
                this.graph.sector.attr("stroke-width", strokeWidth);
                this.graph.circle.attr("stroke-width", strokeWidth);
            }

            this.reflectPropToAttribute(key);
        }

        this.updateGraph();
    }

    _formatValue(t, e) {
        switch (t) {
            case "value":
            case "min":
            case "max":
                e = Number(e);
                if (!Number.isFinite(e)) e = undefined;
                break;

            case "startAngle":
                e = Number(e);
                e = Number.isFinite(e)
                    ? Math.max(0, Math.min(360, e))
                    : undefined;
                break;

            case "anticlockwise":
            case "unconstrained":
                e = !!e;
                break;

            case "indeterminateText":
                e = String(e);
                break;

            case "textFormat":
                if (
                    typeof e !== "function" &&
                    ![
                        "valueOnCircle",
                        "horizontal",
                        "vertical",
                        "percent",
                        "value",
                        "none"
                    ].includes(e)
                ) {
                    throw new Error(
                        `Failed to set the "textFormat" property on CircleProgress: the provided value "${e}" is not a legal textFormat identifier.`
                    );
                }
                break;

            case "animation":
                if (
                    typeof e !== "string" &&
                    typeof e !== "function"
                ) {
                    throw new TypeError(
                        `Failed to set "animation" property on CircleProgress: the value must be either string or function, ${typeof e} passed.`
                    );
                }

                if (
                    typeof e === "string" &&
                    e !== "none" &&
                    !n[e]
                ) {
                    throw new Error(
                        `Failed to set "animation" on CircleProgress: the provided value ${e} is not a legal easing function name.`
                    );
                }
                break;
        }

        return e;
    }

    _valueToAngle(t = this.value) {
        return Math.min(
            360,
            Math.max(0, ((t - this.min) / (this.max - this.min)) * 360)
        );
    }

    _isIndeterminate() {
        return ["value", "max", "min"].some(
            key => typeof this[key] !== "number"
        );
    }

    _positionValueText(t, e) {
        const pos = s(e, t);
        this.graph.textVal.attr({ x: 50 + pos.x, y: 50 + pos.y });
    }

    _initText() {
        const t = this.textFormat;

        this.graph.text.content("");

        if (
            typeof t === "string" &&
            ["valueOnCircle", "horizontal", "vertical"].includes(t)
        ) {
            this.graph.textVal = this.graph.paper.element(
                "tspan",
                { class: "text-value", part: "text-value" },
                "",
                this.graph.text
            );

            if (["horizontal", "vertical"].includes(t)) {
                this.graph.textSeparator = this.graph.paper.element(
                    "tspan",
                    { class: "text-separator", part: "text-separator" },
                    "",
                    this.graph.text
                );
            }

            this.graph.textMax = this.graph.paper.element(
                "tspan",
                { class: "text-max", part: "text-max" },
                "",
                this.graph.text
            );
        }

        switch (t) {
            case "valueOnCircle":
                this.graph.textVal.attr({ x: 0, y: 0, dy: "0.4em" });
                this.graph.textMax.attr({
                    x: 50,
                    y: 50,
                    dy: "0.4em"
                });
                break;

            case "horizontal":
                this.graph.textSeparator.content("/");
                break;

            case "vertical":
                this.graph.textVal.attr({ x: 50, dy: "-0.25em" });
                this.graph.textSeparator.attr({ x: 50, dy: "0.1em" });
                this.graph.textSeparator.content("___");
                this.graph.textMax.attr({ x: 50, dy: "1.2em" });
                break;
        }

        this.graph.text.attr("dy", t === "vertical" ? "" : "0.4em");
    }

    #s = null;

    updateGraph() {
        const offset = this.startAngle - 90;
        const radius = this.getRadius();

        if (this.#s?.cancel()) this.#s.cancel();

        if (this._isIndeterminate()) {
            this._updateText(this.value, offset, radius);
            return;
        }

        const clockwise = !this.anticlockwise;
        let targetAngle = this._valueToAngle();

        this.graph.circle.attr("r", radius);

        if (this.animation !== "none" && this.value !== this.graph.value) {
            this.#s = (function (t, e, a, i, r) {
                const ease = typeof t === "string" ? n[t] : t;

                let start = null;
                let handle;

                const tick = function (now) {
                    if (!start) start = now;

                    let elapsed = now - start;
                    elapsed = Math.min(elapsed, i);

                    const val = ease(elapsed, e, a, i);
                    r(val);

                    if (elapsed < i) {
                        handle = requestAnimationFrame(tick);
                    } else {
                        r(e + a);
                    }
                };

                handle = requestAnimationFrame(tick);

                return {
                    cancel: () => cancelAnimationFrame(handle)
                };
            })(
                this.animation,
                this.graph.value,
                this.value - this.graph.value,
                this.animationDuration,
                r => {
                    targetAngle = this._valueToAngle(r);
                    this.graph.sector.attr(
                        "d",
                        o(50, 50, radius, offset, targetAngle, clockwise)
                    );
                    this._updateText(
                        r === this.value ? r : Math.round(r),
                        (2 * offset + targetAngle) / 2,
                        radius
                    );
                }
            );
        } else {
            this.graph.sector.attr(
                "d",
                o(50, 50, radius, offset, targetAngle, clockwise)
            );
            this._updateText(
                this.value,
                (2 * offset + targetAngle) / 2,
                radius
            );
        }

        this.graph.value = this.value;
    }

    _updateText(t, e, a) {
        if (typeof this.textFormat !== "function") {
            switch (this.textFormat) {
                case "value":
                    this.graph.text.el.textContent =
                        t !== undefined ? t : this.indeterminateText;
                    break;

                case "percent":
                    this.graph.text.el.textContent =
                        (t !== undefined && this.max != null
                            ? Math.round((t / this.max) * 100)
                            : this.indeterminateText) + "%";
                    break;

                case "none":
                    this.graph.text.el.textContent = "";
                    break;

                default:
                    this.graph.textVal.el.textContent =
                        t !== undefined ? t : this.indeterminateText;
                    this.graph.textMax.el.textContent =
                        this.max !== undefined
                            ? this.max
                            : this.indeterminateText;

                    if (this.textFormat === "valueOnCircle") {
                        this._positionValueText(e, a);
                    }
            }
        } else {
            this.graph.text.content(this.textFormat(t, this.max));
        }
    }

    getRadius() {
        return (
            50 -
            Math.max(
                this._getStrokeWidth(this.graph.circle.el),
                this._getStrokeWidth(this.graph.sector.el)
            ) / 2
        );
    }

    _getStrokeWidth(t) {
        return Number.parseFloat(
            this.ownerDocument.defaultView?.getComputedStyle(t)[
                "stroke-width"
            ] || 0
        );
    }
}

customElements.define("circle-progress", u);

export { u as default };
